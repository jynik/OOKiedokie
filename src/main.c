/*
 * Copyright (c) 2015 Jon Szymaniak <jon.szymaniak@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <errno.h>
#include <getopt.h>

#include "version.h"    /* Auto-generated by CMake from version.h.in */
#include "device.h"
#include "sdr/sdr.h"
#include "ookiedokie.h"
#include "ookiedokie_cfg.h"
#include "conversions.h"
#include "find.h"
#include "fir.h"

#define OPTIONS "r:t:d:c:D:p:R:B:A:f:s:b:g:F:v:h"

/* Required */
#define OPTION_RX               'r'
#define OPTION_TX               't'
#define OPTION_DEVICE           'd'

/* TX options */
#define OPTION_TX_COUNT         'c'
#define OPTION_TX_DELAY_US      'D'
#define OPTION_TX_PARAM         'p'

/* RX options */
#define OPTION_RX_RECORD        'R'
#define OPTION_RX_RECORD_INPUT  0x80
#define OPTION_RX_RECORD_DIG    'B'
#define OPTION_RX_FILTER        'F'

/* SDR config */
#define OPTION_SDR_ARGS         'A'
#define OPTION_FREQUENCY        'f'
#define OPTION_SAMPLERATE       's'
#define OPTION_BANDWIDTH        'b'
#define OPTION_GAIN             'g'

/* Stream config */
#define OPTION_SAMPLES_PER_BUF  0x91
#define OPTION_NUM_BUFFERS      0x92
#define OPTION_NUM_TRANSFERS    0x93
#define OPTION_STREAM_TIMEOUT   0x94
#define OPTION_SYNC_TIMEOUT     0x95

/* Other */
#define OPTION_VERBOSITY        'v'
#define OPTION_HELP             'h'

#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))

#define DISABLE_FILTER          ((void *) -1)

static const struct numeric_suffix hz_suffixes[] = {
    { "K",   1000 },
    { "KHz", 1000 },
    { "M",   1000000 },
    { "MHz", 1000000 },
    { "G",   1000000000 },
    { "GHz", 1000000000 },
};

static const struct option long_options[] = {
    { "rx",                     required_argument,  0,  OPTION_RX },
    { "tx",                     required_argument,  0,  OPTION_TX },

    { "device",                 required_argument,  0,  OPTION_DEVICE },

    { "tx-delay",               required_argument,  0,  OPTION_TX_DELAY_US },
    { "tx-count",               required_argument,  0,  OPTION_TX_COUNT },
    { "tx-param",               required_argument,  0,  OPTION_TX_PARAM },

    { "rx-rec",                 required_argument,  0,  OPTION_RX_RECORD },
    { "rx-rec-input",           no_argument,        0,  OPTION_RX_RECORD_INPUT },
    { "rx-rec-dig",             required_argument,  0,  OPTION_RX_RECORD_DIG },
    { "rx-filter",              required_argument,  0,  OPTION_RX_FILTER },

    { "sdr-args",               required_argument,  0,  OPTION_SDR_ARGS },
    { "frequency",              required_argument,  0,  OPTION_FREQUENCY },
    { "samplerate",             required_argument,  0,  OPTION_SAMPLERATE },
    { "bandwidth",              required_argument,  0,  OPTION_BANDWIDTH },
    { "gain",                   required_argument,  0,  OPTION_GAIN},

    { "samples-per-buffer",     required_argument,  0,  OPTION_SAMPLES_PER_BUF },
    { "num-buffers",            required_argument,  0,  OPTION_NUM_BUFFERS },
    { "num-transfers",          required_argument,  0,  OPTION_NUM_TRANSFERS },
    { "stream-timeout",         required_argument,  0,  OPTION_STREAM_TIMEOUT },
    { "sync-timeout",           required_argument,  0,  OPTION_SYNC_TIMEOUT },


    { "verbosity",              required_argument,  0,  OPTION_VERBOSITY },
    { "help",                   no_argument,        0,  OPTION_HELP },

    { 0,                        0,                  0,  0 }
};

static void usage(const char *argv0)
{
    printf("OOKiedokie: Transmit or receive OOK modulated signals (%s)\n\n",
           OOKIEDOKIE_VERSION);

    printf("Usage: %s <--rx | --tx> <SDR type> [options]\n", argv0);
    printf("\n");
    printf("Required parameters:\n");
    printf("  -r, --rx <SDR type>           Receive data.\n");
    printf("  -t, --tx <SDR type>           Transmit data.\n");
    printf("  -d, --device <str>            Target OOK device name.\n");
    printf("\n");
    printf("Transmit options:\n");
    printf("  -c, --tx-count <count>        Number of times to send transmission.\n");
    printf("  -D, --tx-delay <value>        Microseconds to deplay before transmissions.\n");
    printf("  -p, --tx-param <name=value>   Device parameter value to transmit.\n");
    printf("\n");
    printf("Receive options:\n");
    printf("  -F, --rx-filter <filename>    Use the specified filter. This may be\n");
    printf("                                the full path or just name for filter files\n");
    printf("                                in the OOKiedokie search path.\n");
    printf("  -B, --rx-rec-dig <filename>   Save digital signal to a CSV of binary values,\n");
    printf("                                as specified by <filename>\n.");
    printf("  -R, --rx-rec <SDR type>,<file>\n");
    printf("                                Record RX'd samples to specified file using\n");
    printf("                                <SDR type>, which must be one of the available\n");
    printf("                                file-based implementations.\n");
    printf("\n");
    printf("  --rx-rec-input                Specifies that --rx-rec should record raw input\n");
    printf("                                rather than filtered samples.\n");
    printf("\n");
    printf("SDR configuration options:\n");
    printf("  -A, --sdr-args <args>         SDR-specific arguments.\n");
    printf("  -f, --frequency <freq>        Set the SDR to the specified frequency.\n");
    printf("  -s, --samplerate <rate>       Set the SDR to the specified sample rate.\n");
    printf("  -b, --bandwidth <bw>          Set the SDR to the specified bandwidth.\n");
    printf("  -g, --gain <gain>             Set the SDR to the specified gain.\n");
    printf("\n");
    printf("Sample stream options:\n");
    printf("  --num-buffers <n>             Allocate <n> sample buffers.\n");
    printf("  --samples-per-buffer <n>      Allocate <n> samples in each sample buffer.\n");
    printf("  --num-transfers <n>           Utilize up to <n> simultaneous USB transfers.\n");
    printf("  --stream-timeout <n>          Set stream timeout to <n> milliseconds.\n");
    printf("  --sync-timeout <n>            Set sync function timeout to <n> milliseconds.\n");
    printf("\n");
    printf("Other options:\n");
    printf("  -v, --verbosity <level>       Set the output verbosity level.\n");
    printf("  -h, --help                    Show this help text.\n");
    printf("\n");
}

static int append_device_param(struct ookiedokie_cfg *cfg, char *str)
{
    bool success;
    struct keyval kv;
    char *sep = strchr(str, '=');

    if (!sep) {
        fprintf(stderr, "Error device parameter is not in the "
                        "form <key>=<value>: %s\n", str);
        return -1;
    }

    kv.value = sep + 1;
    *sep = '\0';
    kv.key = str;

    success = keyval_list_append(cfg->device_params, &kv);
    if (!success) {
        fprintf(stderr, "Failed to append %s=%s to parameter list.\n",
                kv.key, kv.value);
        return -1;
    }

    return 0;
}

static int get_rx_recorder(struct ookiedokie_cfg *cfg, char *arg)
{
    char *sep;

    if (cfg->rx_rec_filename != NULL || cfg->rx_rec_type != NULL) {
        fprintf(stderr, "Error: RX recording parameters already specified.\n");
        return -1;
    }

    sep = strchr(arg, ',');
    if (!sep) {
        fprintf(stderr, "Error: RX recording must be specified as <SDR type>:<filename>\n");
        return -1;
    }

    *sep = '\0';

    cfg->rx_rec_type = strdup(arg);
    if (!cfg->rx_rec_type) {
        perror("strdup");
        return -1;
    }

    cfg->rx_rec_filename = strdup(sep + 1);
    if (!cfg->rx_rec_filename) {
        perror("strdup");
        return -1;
    }

    return 0;
}

static int validate_cfg(struct ookiedokie_cfg *cfg)
{
    int status = 0;
    const bool have_device      = (cfg->device != NULL);
    const bool have_rx_filter   = (cfg->rx_filter != NULL);
    const bool have_rx_rec      = (cfg->rx_rec_filename != NULL &&
                                   cfg->rx_rec_type     != NULL);

    switch (cfg->direction) {
        case DIRECTION_RX:
            if (!cfg->device && !have_rx_rec) {
                fprintf(stderr, "Error: Either a target device or "
                                "recording parameters must be specified.\n");
                return -1;
            }

            break;

        case DIRECTION_TX:
            if (!have_device) {
                status = -1;
                fprintf(stderr, "Error: A target device must be specified.\n");
            } else if (have_rx_rec) {
                status = -1;
                fprintf(stderr, "Error: --rx-rec cannot be specified with --tx\n");
            } else if (have_rx_filter) {
                status = -1;
                fprintf(stderr, "Error: --rx-filter cannot be used with --tx.\n");
            }
            break;

        default:
            status = -1;
            fprintf(stderr, "Error: --rx <SDR type> or "
                            "--tx <SDR type> must be specified.\n");
    }

    return status;
}

static int process_cmdline(int argc, char *argv[], struct ookiedokie_cfg *cfg)
{
    int c;
    bool ok;
    int status = 0;

    while ((c = getopt_long(argc, argv, OPTIONS, long_options, NULL)) >= 0) {
        switch (c) {
            case OPTION_RX:
                if (cfg->direction == DIRECTION_TX) {
                    fprintf(stderr, "Error: --rx and --tx may not be specified "
                                    "together.\n");
                    return -1;
                } else {
                    cfg->direction = DIRECTION_RX;
                }

                if (cfg->sdr_type != NULL) {
                    fprintf(stderr, "Error: --rx already specified.\n");
                    return -1;
                } else {
                    cfg->sdr_type = strdup(optarg);
                    if (!cfg->sdr_type) {
                        perror("strdup");
                        return -1;
                    }
                }
                break;

            case OPTION_TX:
                if (cfg->direction == DIRECTION_RX) {
                    fprintf(stderr, "Error: --rx and --tx may not be specified "
                                    "together.\n");
                    return -1;
                } else {
                    cfg->direction = DIRECTION_TX;
                }

                if (cfg->sdr_type != NULL) {
                    fprintf(stderr, "Error: --tx already specified.\n");
                    return -1;
                } else {
                    cfg->sdr_type = strdup(optarg);
                    if (!cfg->sdr_type) {
                        perror("strdup");
                        return -1;
                    }
                }

                break;

            case OPTION_DEVICE:
                if (cfg->device) {
                    fprintf(stderr, "Error: device already specified.\n");
                    return -1;
                } else {
                    cfg->device = strdup(optarg);
                    if (!cfg->device) {
                        perror("strdup");
                        return -1;
                    }
                }
                break;

            case OPTION_TX_DELAY_US:
                cfg->tx_delay_us = str2uint(optarg, 0, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid TX delay value: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_TX_COUNT:
                cfg->tx_count = str2uint(optarg, 1, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid tx count: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_TX_PARAM:
                status = append_device_param(cfg, optarg);
                if (status != 0) {
                    return status;
                }
                break;

            case OPTION_RX_RECORD:
                status = get_rx_recorder(cfg, optarg);
                if (status != 0) {
                    return status;
                }
                break;

            case OPTION_RX_RECORD_INPUT:
                cfg->rx_rec_input = true;
                break;

            case OPTION_RX_FILTER:
                if (cfg->rx_filter != NULL) {
                    fprintf(stderr, "Error: RX filter already specified.\n");
                    return -1;
                } else if (!strcasecmp("none", optarg)) {
                    cfg->rx_filter = DISABLE_FILTER;
                } else {
                    cfg->rx_filter = strdup(optarg);
                    if (!cfg->rx_filter) {
                        perror("strdup");
                        return -1;
                    }
                }
                break;

            case OPTION_RX_RECORD_DIG:
                if (cfg->rx_rec_dig != NULL) {
                    fprintf(stderr, "Error: RX digtial output file already specified.\n");
                    return -1;
                } else {
                    cfg->rx_rec_dig = strdup(optarg);
                    if (!cfg->rx_rec_dig) {
                        perror("strdup");
                        return -1;
                    }
                }
                break;

            case OPTION_SDR_ARGS:
                if (cfg->sdr_args != NULL) {
                    fprintf(stderr, "Error: SDR args were already specified.\n");
                    return -1;
                } else {
                    cfg->sdr_args  = strdup(optarg);
                    if (!cfg->sdr_args) {
                        perror("strdup");
                        return -1;
                    }
                }
                break;

            case OPTION_HELP:
                return 1;
                break;

            case OPTION_VERBOSITY:
                cfg->verbosity = str2loglevel(optarg, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid verbosity level: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_FREQUENCY:
                cfg->frequency =
                    str2uint_suffix(optarg,
                                    0,
                                    4000000000,
                                    hz_suffixes, ARRAY_SIZE(hz_suffixes),
                                    &ok);

                if (!ok) {
                    fprintf(stderr, "Invalid frequency: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_SAMPLERATE:
                cfg->samplerate =
                    str2uint_suffix(optarg,
                                    1,
                                    100000000,
                                    hz_suffixes, ARRAY_SIZE(hz_suffixes),
                                    &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid sample rate: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_BANDWIDTH:
                cfg->bandwidth =
                    str2uint_suffix(optarg,
                                    1,
                                    100000000,
                                    hz_suffixes, ARRAY_SIZE(hz_suffixes),
                                    &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid bandwidth: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_GAIN:
                cfg->gain = str2int(optarg, -100, 100, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid gain: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_NUM_BUFFERS:
                cfg->num_buffers = str2uint(optarg, 1, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid buffer count: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_SAMPLES_PER_BUF:
                cfg->samples_per_buffer = str2uint(optarg, 1, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid buffer size (in samples): %s\n",
                            optarg);
                    return -1;
                }
                break;

            case OPTION_NUM_TRANSFERS:
                cfg->num_transfers = str2uint(optarg, 1, UINT_MAX, &ok);

                if (!ok) {
                    fprintf(stderr, "Invalid transfer count: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_STREAM_TIMEOUT:
                cfg->stream_timeout_ms = str2uint(optarg, 0, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid stream timeout: %s\n", optarg);
                    return -1;
                }
                break;

            case OPTION_SYNC_TIMEOUT:
                cfg->sync_timeout_ms = str2uint(optarg, 0, UINT_MAX, &ok);
                if (!ok) {
                    fprintf(stderr, "Invalid sync function timeout: %s\n", optarg);
                    return -1;
                }
                break;

            default:
                return -1;
        }

    }

    return status;
}

int main(int argc, char *argv[])
{
    int status;
    struct sdr *sdr = NULL;
    struct sdr *rx_recorder = NULL;
    struct device *dev = NULL;
    struct fir_filter *filter = NULL;
    struct ookiedokie_cfg cfg;

    ookiedokie_cfg_init(&cfg);

    /* Override defaults with command-line arguments */
    status = process_cmdline(argc, argv, &cfg);
    if (status == 1) {
        usage(argv[0]);
        return 0;
    } else if (status != 0) {
        /* We got some bad arguments */
        return status;
    }

    status = validate_cfg(&cfg);
    if (status != 0) {
        status = EXIT_FAILURE;
        goto out;
    }

    /* Apply log level before we do anything else */
    log_set_verbosity(cfg.verbosity);

    /* Open and initialize the SDR hardware or file format handler */
    sdr = sdr_init(&cfg, false);
    if (!sdr) {
        fprintf(stderr, "\nUnable to initialize the specified device.\n");
        fprintf(stderr, "Run with -v debug or -v verbose for more information.\n\n");
        status = EXIT_FAILURE;
        goto out;
    }

    /* RX recorder setup */
    if ((cfg.rx_rec_filename != NULL) && (cfg.rx_rec_type != NULL)) {
        struct ookiedokie_cfg rec_cfg;

        rec_cfg.direction = DIRECTION_TX;
        rec_cfg.sdr_type = cfg.rx_rec_type;
        rec_cfg.sdr_args = cfg.rx_rec_filename;
        rec_cfg.samples_per_buffer = cfg.samples_per_buffer;

        rx_recorder = sdr_init(&rec_cfg, true);
        if (!rx_recorder) {
            fprintf(stderr, "Unable to open %s for writing\n", rec_cfg.sdr_args);
            status = EXIT_FAILURE;
            goto out;
        }
    }

    /* RX filter */
    if (cfg.rx_filter != NULL) {
        if (cfg.rx_filter == DISABLE_FILTER) {
            /* User has opted out of using any default filter for the
             * selected SDR. */
            cfg.rx_filter = NULL;
        } else {
            filter = fir_init(cfg.rx_filter, cfg.samples_per_buffer);
            if (!filter) {
                status = EXIT_FAILURE;
                goto out;
            }
        }
    } else if (cfg.direction == DIRECTION_RX) {
        const char *default_filter = sdr_default_filter(sdr);

        if (default_filter) {
            filter = fir_init(default_filter, cfg.samples_per_buffer);
        }

        if (filter == NULL) {
            log_warning("No default filter found for %s. "
                        "No filter is being used.\n", cfg.sdr_type);
        } else {
            log_verbose("Using default filter for %s: %s\n",
                        cfg.sdr_type, default_filter);
        }
    }

    /* Force any file recording to occur pre-filter */
    if (filter == NULL) {
        cfg.rx_rec_input = true;
    }

    /* Load the state machine for the target device */
    if (cfg.device) {
        unsigned int decimation;

        if (filter) {
            decimation = fir_get_total_decimation(filter);
        } else {
            decimation = 1;
        }

        dev = device_init(cfg.device, cfg.samplerate / decimation);
        if (!dev) {
            status = EXIT_FAILURE;
            goto out;
        }
    }

    switch (cfg.direction) {
        case DIRECTION_RX: {
            status = ookiedokie_rx(sdr, filter, dev, rx_recorder, &cfg);
            break;
        }

        case DIRECTION_TX:
            status = ookiedokie_tx(sdr, dev, &cfg);
            break;

        default:
            log_error("(BUG) Invalid direction encounted!\n");
            status = -1;
            break;
    }

    if (status != 0) {
        status = EXIT_FAILURE;
    }

out:
    device_deinit(dev);
    sdr_deinit(sdr);
    sdr_deinit(rx_recorder);
    ookiedokie_cfg_deinit(&cfg);
    fir_deinit(filter);

    return status;
}
